# 원시 값과 객체의 비교
## 원시값
- 원시값은 실제값을 표현하는 이진수가 들어간다.
- 상수도 실체는 변수지만 재할당이 불가능한 변수이다.(할당은 한번만 가능)
- string은 크기를 알 수 없기 때문에 원시값처럼 쓸 수 있게 해주기 위해서 유사 배열을 사용했다.
- immutable value는 재할당 이외의 방법으로 값을 바꿀 수 없기 때문에 신뢰성이 부여된다.
- mutable value는 바뀔 수 있다.
- 객체를 원시값처럼 쓰기 위해서 얼린다.(못 고치게 바꾼다.)
- 객체는 원시값에 비해서 크다.
- immutable은 보통 작은 값이기에 복사를 해서 다른 메모리에 할당해도 큰 문제가 생기지는 않는다.
  - 별개로 아무리 카피를 한 값이라도 둘은 값은 모습을 한 값이지만 다른 메모리에 저장된 별개의 값이다.
  - 가비지 컬렉터는 할당을 해제하는 역할을 한다. (지우는 역할이 아님)
  - 할당을 해제하는 일이 제대로 되지 않으면 momory leak가 발생한다.
## 객체
- 프로퍼티들의 집합
- 딕셔너리는 값을 찾을 때 이름으로 찾고 리스트에서는 값을 찾을 때 순서로 찾는다.(리스트에는 순서의 개념이 있는 것)
- 객체를 할당하면 변수에는 객체값이 아닌 객체를 가리키는 주소값이 할당된다.(참조 값)
- 객체를 할당한 변수는 "변수는 객체를 가리키고(point)있다"라고 표현한다.
- 재할당을 하지 않아도 추가와 갱신이 가능하다.
- 객체를 가리키는 변수는 복사할 시 참조에 의한 전달(Pass by reference)이 된다. 가지고 있는 주소를 카피해서 보내기 때문에 가리키는 객체는 같은 객체가 되기 때문에 한 객체를 공유하는 형태가 된다.
- 객체가 바뀌면 복사를 해간 다른 변수도 값이 바뀌게 된다.
- 얕은 복사(shallow copy)는 참조 값만을 복사, 깊은 복사(deep copy)는 객체 자체를 복사해서 새로 할당하는 방식.

# 함수
## 함수란?
- function 키워드를 사용해서 함수명을 선언하고 매개변수를 입력해준다. 그 뒤를 이어 함수 몸체 블럭이 들어온다. 함수 몸체 블럭에는 일괄실행될 문들이 들어간다.
- 함수 정의만을 가지고는 함수를 실행 할 수 없다.
- 함수를 실행하기 위해서는 함수를 호출해야 한다.
- 호출을 하기 위해서 매개변수에 값을 순서대로 할당(값을 복사해서 넘기므로 pass by value, 참조값을 복사해서 넘기면 pass by reference)하면 함수 내에서 문을 실행하고 return문을 통해서 값을 반환한다.
- 함수를 사용하는 이유는 '재사용'을 위해서이다
  - 코드를 유지보수 하는 측면에 있어서 실수를 줄이고 품질의 상승과 더불어 생산성까지 올라간다.
  - 비슷한 예를 보면 함수를 만들어 재사용 할 수 있도록 해야한다.
## 함수 정의
- 함수 선언문
  - 함수 선언문이 변수에 선언된 상태에서는 함수 리터럴로 해석한다.
  - 함수명을 통해서 렉시컬 환경에 식별자로 등록하고 변수처럼 동작한다.
  - 함수 호이스팅
- 함수 표현식
  - 변수에 할당문을 더한 모양
  - 변수 호이스팅을 한다. 
- function 생성자 함수
  - 사용하면 안됨
- 화살표 함수
  - 함수 선언문과 함수 표현식을 대체하기 위해서 만들어진 존재가 아님. 꼭 필요할 상황에만 사용한다.
- 함수 선언문과 함수 표현식 중 어떤 것을 쓰던 일관성 있게 쓰는 것이 중요하다.
### 함수 선언문
- 함수 선언문에서 함수명이 없으면 에러가 난다.
- 자바스크립트에서 함수는 객체
- 함수 표현식과 함수 선언문은 결국 같아진다.
- 함수 선언문은 변수 선언과 초기화 단계가 한 번에 이루어진다. undefined는 할당되지 않고 바로 함수 객체가 들어간다.(함수 호이스팅)
- 함수 객체는 호출 할 수 있다.
## 함수 호출
- 인수(argument), 매개변수(parameter, 인자)
## 매개변수와 인수
- 인수가 모자라게 들어가면 초기화된 매개변수 값에 아무것도 들어가지가 않아 undefined가 그대로 남아있는 상태가 된다.
## 매개변수의 개수
- 객체 순서는 의미가 없다. 키값을 통해서 값을 받아오기 때문이다.
## 외부 상태의 변경과 함수형 프로그래밍
- mutable value를 immutable value로 바꿔서 쓰면 객체 프로퍼티가 바뀌는 걸 신경쓰지 않아도 된다.
## 반환문
- return을 통해 값을 반환한다. return 뒤에는 표현식
- 반환된 값을 받아주지 않으면 의미없는 값이 되어버린다.
- 값을 반환하는 것 이외에 종료시키는 의미도 있음
- return문 이후에 오는 문들은 실행되지 않는다.
## 다양한 함수의 형태
### 즉시실행함수
- 단 한 번만 쓰기 위한 함수 (하지만 활용빈도가 높음)
- 활용 후 메모리 할당도 바로 해제됨.
- 반드시 그룹 연산자로 막아줘야함(그렇지 않으면 에러)

```
가장 보편적인 방법!
(function () {
  //...
}());
```
- 자바스크립트는 전역 스코프가 하나
  - 파일을 쪼개도 하나인것처럼 동작함
  - 이를 해결하기 위해서 함수 스코프를 생성해서 사용(옛 방식)
  - 최근 방식은 모듈을 만들어서 사용
- 인위적인 스코프를 만들고 싶을 때
- 클로저를 만들 때
### 재귀 함수
- 꼭 쓰지 않아도 될 때에는 쓰지 않는 것을 추천
- 함수 안에서 자기 자신을 호출하는 방식으로 자기 자신을 무한히 호출하는 상황이 생길 수 있음
- 콜스택에 엄청난 양을 쌓다가 치명적인 스택 오버플로우 에러를 발생시킬 수 있다.
- 탈출 조건이 필수적이며 행여나 탈출 조건에 문제가 있을 경우 서버를 재시작해야하는 경우도 생길 수 있다.
- 그러므로 재귀함수를 써서 가독성이 좋아지거나 무조건 써야만 하는 상황이 아니라면 사용하지 않는 것을 추천
### 중첩 함수
- 함수가 함수 안에서 정의되는 경우
  - 함수가 길어지는 경우(대부분의 경우 함수는 짧을수록 좋다) 가독성을 위해서 외부함수를 돕기 위해서 내부에서 help 함수의 역할을 한다.(스코프도 중첩됨)
- 스코프는 식별자를 관리하기 위해서 존재한다. 스코프가 중첩되면 스코프끼리도 상하 관계가 형성된다.(스코프 체인)
### 콜백 함수
- 콜백 함수는 내부에 help 함수를 집어넣는 역할을 한다.
- 값으로 쓸 수 있는 함수를 일급 객체라고 한다.
- 함수를 호출할 때 함수를 전달하는 일(함수 합성)을 한다.
- 큰 의미로는 중첩함수
- print()는 식별자 print를 통해서 괄호 안에 있는 함수를 호출한다.
- 함수가 인수에 따라서 하는 역할이 달라진다.
- 대부분의 함수는 콜백 함수
- 콜백 함수의 장점은 필요한 상황에 맞춰서 바꿔 사용할 수 있다는 것.

# 스코프
- name binding
- 식별자는 혼자 있으면 아무런 의미가 없다.
- 스코프는 자바스크립트에 의해 관리되는 자료구조의 형태 : 식별자와 값의 binding으로 구성
- 변수는 전역, 함수내부 등등 모든 코드 블럭 안에서 선언할 수 있다.
- var로 선언한 변수는 block-level scope를 지원하지 않는다. 하지만 함수 레벨 스코프를 지원한다.
- let, const로 선언한 변수는 블록 레벨 스코프를 지원한다.
- 변수는 어디에서 선언하는지가 중요하다.
- 상위 스코프에서는 하위 스코프를 볼 수 없고, 하위 스코프에서는 상위 스코프를 볼 수 있다. 
- 전역 변수는 어디서든 다 볼 수 있다.
## 스코프란?
- 변수를 검색할 때 사용하는 규칙
## 스코프의 종류
- 전역 스코프와 지역 스코프
### 전역과 전역 스코프
- 스코프 체인을 거슬러 올라가면서 식별자를 찾는다.
- 내부에서부터 외부로 식별자를 찾아나간다.
## 스코프 체인
- 중첩이 있어야 스코프 체인을 만든다.
- 렉시컬 환경(Lexical Environment) : 환경 = 스코프, 어휘에 따라서 스코프가 만들어진다는 의미와 비슷.
## 스코프 체인에 의한 함수 검색
- 선언을 하면 식별자가 만들어진다.
- 블록 레벨 스코프는 ECMA6부터 의미가 생겼다.
- var와 let, const는 혼용할 수 없다.
## 렉시컬 스코프
- 클로저와 관련
- 스코프는 어디서 시작되는가
- 호출되지 않은 함수 안까지 보지 않는다.
- 선언된 위치에서 상위 스코프를 찾아본다. 이를 렉시컬 스코프라고 한다.
## 암묵적 전역 변수
- var 없이 변수에 값을 할당하면 전역변수가 된다.(잡기 힘든 에러)
- i 변수는 함부로 쓰면 안된다.
  - 반복문에서 i를 사용하는 경우가 많으므로 전역변수가 재할당 되는 경우가 생길 수 있다.