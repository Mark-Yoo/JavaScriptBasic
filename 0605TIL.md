# 실행 컨텍스트
- 핵심 개념의 중요점은 개념을 아는 것으로 자바스크립트가 어떻게 동작할지 안다는 의미이다.
- 자바스크립트는 문맥적으로 문법을 맞춘다.
- 식별자 => 선언이 중요 (프로퍼티는 식별자라고 잘 부르지 않음) 식별자는 보통 프로토타입에서 찾으므로 식별자라고 특별히 부르지는 않는다.
## 1. 실행 가능한 코드
- ECMAScript 사양은 실행 가능한 코드(Executable Code)를 4가지 유형으로 구분한다.
```
eval 코드(Eval code)는 이미 빌드된 스코프를 뒤흔들기 때문에 사용하는 것이 좋지 않다.
```
- 전역 스코프에는 전역 변수가 없고 전역 객체에 프로퍼티 상태로 존재한다.
```
window.x로도 찾을 수 있어야하며, x로도 찾을 수 있어야 한다.
```
- 전역 코드는 자바스크립트에만 존재, 다른 언어들과는 다르게 진입점이 없다.
```
1. 전역 코드: 전역 스코프를 생성, 전역 코드가 평가되면 전역 실행 컨텍스트가 생성됨
2. 함수 코드: 지역 스코프를 생성, 지역 스코프의 최상위인 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결되어야 함.
```

- 선언문들이 먼저 실행되면서 그 식별자들을 등록하기 위해서 실행 컨텍스트를 만들고 여기에 식별자들을 등록한다. 등록이 끝나야 비로소 런타임이 시작된다.

```
var x = 10;
위에서 x는 전역 컨텍스트의 프로퍼티가 된다.
전역 실행 컨텍스트에 x는 undefined라고 들어간다. (이 때가 코드 평가중)
할당은 식별자를 찾아야하므로 전역 실행 컨텍스트로 찾아간다.

var x = 10;
function foo(a) {
  var x = 10 + a;
}

```
- 변수 선언이란 변수명을 실행 컨텍스트에 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것. 실행 컨텍스트에 값을 넣어야 등록을 할 수 있었기에 undefined를 넣어 등록한것.
- 함수선언문은 함수명을 가지고 식별자를 만든것이므로 일급객체인 함수를 코드 평가에서 할당한다.
- 전역에서 참조가 발생하면 전역에서부터 찾기 시작한다.
- 객체는 내부메서드로 [[call]]을 가지고 있으며 console.log로 이 내부메서드를 호출하는 것이다.
- 지역 실행 컨텍스트에서 그 위에 있는 전역 컨텍스트는 shadowing 된다.
- 함수 실행이 끝나면 함수 실행 컨텍스트는 소멸되고 다시 전역에서 실행하던 곳으로 돌아간다.
- 함수를 평가할 때 argument 객체도 생성되어 지역 스코프에 등록된다.
- 파라미터가 없는 함수 내부에서 argumnets를 호출하면 함수를 호출할 때에 들어온 인자들을 전부 유사 배열 객체로 바꿔 리턴한다. arguments는 원래 프로퍼티로 사용하게 되어있었지만 현재는 폐지되어 함수내부에서 보이게 되었다. arguments를 만들 때 실행 컨텍스트에 저장하게 된다.
- 실행 컨텍스트(execution context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 겨로가를 실제로 관리하는 영역 (코드가 실행될 때 그 값을 모두 저장하고 관리하는 역할) : 변수는 프로퍼티가 되어 실행 컨텍스트에 들어감.
- 식별자가 스코프 단위로 들어가며 스코프가 중첩되면서 스코프 체인이 만들어진다.
- 실행 컨텍스트 스택(Execution context stack)이라는 스택(stack) 자료 구조로 관리된다. 자바스크립트는 이 콜스택이 하나만 존재하기 때문에 싱글 스레드라고 부른다.
- 전역 실행 컨텍스트는 파일이 로드되자마자 파싱이 끝나자마자 만들어진다.
  - 전역 객체가 만들어지고 이후에 전역 실행 컨텍스트가 만들어진다. 그러므로 항상 스택의 맨 밑에 존재하고 사라지지 않는다. 전역 실행 컨텍스트가 사라지는 순간 어플리케이션이 종료되는 것.
  - 맨 위에 있는 것은 현재 실행 중인 실행 컨텍스트 (running execution context)
- 이러한 동기식 방식을 탈피하기 위해 비동기식 방식을 사용하기위해 ajax를 사용하지만 이 ajax는 에러를 잡는 것이 난해하고, 콜백헬이 생기므로 프로미스를 사용한다.
- 렉시컬 환경(Lexical Environmnet)는 스코프를 의미한다.

- Lexical Environment는 3가지의 컴포넌트를 갖는다.
  - EnvironmentRecord
  - Outer Lexical Environment Reference : 상위 스코프에 대한 참조
  - ThisBinding

- Global environment record로 식별자가 들어가면 object environemtn record의 BindingObject로 연결된다. 이 BindingObject는 전역인 브라우저 환경의 window나 node 환경의 global object에 연결이 되어 이 식별자로 들어온 값은 모두 여기로 향한다.
  - 전역에서 window를 붙여 찾다가 만약 여기에서 찾지 못한 경우 Declarative Environment Record로 옮겨 찾는다.
- 로드 된 직후 전역 객체를 만든다(전역 객체는 생성자 함수를 제공하지 않으므로 우리가 직접 만들 수 있는 방법은 전혀 없다.)
- 이 후 전역 코드에 대한 평가가 시작된다.
- 식별자들을 끄집어내서 식별자들을 등록하기 시작함. : 전역 렉시컬 환경의 첫번째 컴포넌트인 환경 레코드에 등록하려고 한다. var로 선언된 변수는 객체 환경 레코드라는 곳으로 들어가서 bindingobject, 즉 전역 객체의 프로퍼티로 저장된다. const는 declarative Environment Record로 들어가서 초기화가 되지 않은 상태로 존재한다. 결론적으로 var로 선언된 전역 변수와 전역 객체는 window의 프로퍼티가 된다는 것. foo를 호출하면 전역 객체에서 찾아나간다.
- 전역 코드가 실행되면 실행 컨텍스트 스택 최상위에 전역 실행 컨텍스트가 있으므로 여기에서 찾기 시작한다.
- 함수가 정의되고 평가되는 시점에 이미 상위 스코프를 알고 있다. 함수는 객체이므로 숨겨진 프로퍼티를 갖는데 생성될 때 이 내부 슬롯에 상위 스코프를 가지고 가지고 다니게 된다. 그러므로 정적인 스코프, 즉 렉시컬 스코프를 갖게 되는 것이다.
- 함수는 자신이 정의된 곳에서 평가된다. 어디에서 정의되었는지에 따라서 상위 스코프가 정해진다. 예를들어 함수 bar는 상위의 함수인 foo가 평가될 때 함수 객체가 만들어진다. 결론적으로 모든 함수는 다 클로저이다.
- 함수 실행 컨텍스트는 전역실행 컨텍스트에 비해 심플하다. ThisBinding은 동적으로 정해진다. 화살표 함수는 this가 없고 lexical this를 참조할 수 있다. (상위 지점의 this) this를 참조하는 순간 메소드가 돈다.
- bar 함수 코드 평가
  - z를 bar함수 실행 컨텍스트의 렉시컬 환경 컨텍스트에 저장한다.(여기에서 평가는 끝)
  