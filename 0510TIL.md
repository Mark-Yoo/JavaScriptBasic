# 0510TIL
## 지역변수와 전역변수
- 전역 변수는 애플리케이션을 종료하기 전까지 사라지지 않는다.
- 지역 변수는 블럭 내의 문이 모두 종료되면 사라진다.
- 모든 변수는 변수로 인해 생길 수 있는 예기치 못한 에러를 예방하기 위해 최대한 짧은 함수 코드를 짜는 것이 이상적이다.(스코프를 최대한 작게 만드는 것이 좋다.)
##. 전역 변수의 문제점
- 암묵적 결합
- 긴 생명 주기
- 스코프 체인 상에서 종점에 존재
- 네임 스페이스를 오염
## 전역 변수 사용 억제 방법
- 즉시 실행 함수 (확실하고 빠른 방법)
- 네임 스페이스 객체 (오래된 방법 : 실제로는 전역 변수를 결국 선언하는 것이됨)
- 모듈 패턴 : 대중적으로 인정 받은 방식으로 만든 예제
```
var counter = (function () {
  var num = 0;
  return {
    increase() {
      return ++num;
    }
  }
}());
```
counter는 즉시실행함수의
```
increase() {return ++num}
```
가 들어간다.

```
var counter = {
  _num: 0,
  increase() {
    return ++this._num;
  },
  decrease() {
    return --this._num;
  }
};
```
이 코드의 문제점은 변수를 바깥에서도 접근할 수 있다는 점이다.

- 캡슐화란 접근해서 건드리면 안되는 변수를 감추는 역할이다.
- 중첩함수가 외부함수보다 오래 살아남아있으면 클로저(closure)라고 한다.
- 함수 객체가 생성되어질 때 자신의 상위 스코프를 가지고 있는다.(렉시컬 스코프) 그러므로 함수 객체는 죽기 전까지 상위 스코프의 변수를 가지고 있게 되는데 이것이 클로저이다. 결국 상위에 있는 변수는 자유변수라고도 불리운다. (이러한 방식으로 모듈 패턴에서 변수 정보가 은닉된다.)
- 클로저 내에서는 하위 객체가 참조하고 있는 상위 객체의 변수만을 기억한다.(최대한 메모리를 아끼기 위한 방법)
- 모듈에서는 import, export을 사용해서 하면 된다.(제대로 공개된 스펙은 아직 없다.)
  - Webpack과 babel을 이용해서 구현할 수 있다.
- 자바스크립트는 전역 스코프가 하나이므로 아무리 페이지를 쪼개도 아무런 의미가 없다.
## let, const와 블록 레벨 스코프
- 처음에는 일단 재할당이 불가능한 const로 작성하고 이후에 재할당이 필요하다면 let으로 수정한다.
- var로 선언한 암묵적 전역 변수들은 전역 객체 (window)의 프로퍼티가 된다. 하지만 호출 할 때에는 window를 생각하는 것이 가능하다.
- let으로 선언한 전역 변수는 widnow의 프로퍼티가 아니다. let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 된다.
- const는 선언과 동시에 할당까지 해줘야한다. 재할당은 불가능하다.
- const 내에 객체를 넣을 경우 그 객체의 프로퍼티 값은 변경이 가능하다. const에 저장되어있는 참조 값만 변경이 불가능한다.
- var와 let을 혼용하지 말 것. 
## 프로퍼티 정의
- 프로퍼티를 생성하는 것은 정의가 아니다.
- 프로퍼티의 정체를 알리는 것.
```
const o = {
  a: 1,
  b: 2,
};
```
 이 값 이외에 다른 것들이 프로퍼티에 포함되어 있다.
```
const o = {
  a: 1,
  b: 2,
};

console.log(Object.getOwnPropertyDescriptor());
```
Object.getOwnPropertyDescriptor()를 사용하면 프로퍼티의 어트리뷰트를 볼 수 있다. 이 어트리뷰트 설정을 바꾸면 속서잉 바뀐다. 자바스크립트 엔진은 디폴트 값으로 이를 설정해준다.
- 데이터 프로퍼티는 어트리뷰트 밸류를 갖는데 접근자 프로퍼티는 밸류가 없다.
- 접근자 프로퍼티는 함수
## 생성자 함수에 의한 객체 생성
- 리터럴은 하나씩 만드는 것
- 생성자 함수는 여러개의 객체를 만든다는 가정하게 쓴다. (하나만 만들 때에는 비효율적)
- 파라미터를 통해 프로퍼티 값을 입력받는다.
- Object 생성자 함수는 자바스크립트 빌트인 객체
- new연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.
```
const obj = new.Object();
obj.a = 1;
obj.b = 10;
```
위 방법은 그다지 효용성이 없으나 새 배열을 만드는 방법 중 하나이다.
```
const str = 'HI';
console.log(str.toLowerCase());
```
래퍼 객체 : 위 방법처럼 const를 사용하면 결과값을 반환하지만 const str의 값은 바뀌지 않는다.


```
Number('123')
```
이 함수는 형변환을 시키지만 형변환을 위해서 사용하지 않는다. 
- object 생성자 함수는 그다지 유용해보이지 않는다.


```
const empty = {};
```
빈 객체를 만들 때에는 복잡하지 않은 베스트 방법이다.
- 생성자 함수가 만든 개체는 인스턴스 라고 부른다.
- 기본적으로 객체 리터럴은 하나만 만들 때에 사용한다.
- new를 사용하지 않고 호출을 하면 전역 객체인 window에서 불러오는 것이므로 new를 반드시 사용해서 호출해야 한다.
```
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}
```
위 코드에서 function circle(radius)를 하면 빈 객체를 생성한다. this는 호출한 곳 생성할 객체를 지칭한다.

- 생성자 함수로 호출이란 new를 붙여서 호출
- 함수는 다양한 방식으로 호출할 수 있고 그 때마다 this는 동적으로 결정된다.
## 내부 메소드 [[Call]]과 [[Constructor]]
- 함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다.
  - 일반 함수 호출 : [[Call]]
  - new를 붙여 호출 : [[Constructor]]
- 화살표 함수는 콜백 함수에서 많이 사용됨.
```
const arr = [1, 2, 3, 4, 5];

const filtered = arr.filter(function (item) {
  return item > 2;
});

console.log(filtered);
```
아래의 식은 화살표 함수를 이용하여 위 함수를 짧게 만든것이다. 둘은 같은 기능을 한다.
```
const arr = [1, 2, 3, 4, 5];

const filtered = arr.filter(item => item > 2);

console.log(filtered);
```
- 메서드 축약표현으로 만든 함수는 [[Constructor]]가 없으므로 생성자 함수를 호출 할 수 없다.
- this를 암묵적으로 return 할 때 명시적으로 return {};를 통해서 객체를 반환하면 this 반환이 무시된다. 원시값일 경우에는 무시되지 않고 return 된다. 일관성이 없으므로 좋지 않은 코딩 방식이다.



- 제대로 된 스펙 공부를 하기 위해서는 모질라 재단 홈페이지에서 공부하는 것이 좋다.