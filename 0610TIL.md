# 0610TIL
## SPA (Single Page Application & Routing)
- HTML은 단 하나, css와 js는 하나일수도 여러개일수도 있다 (webpack을 통해 분할 혹은 통합 가능)
- 여러개로 나눌 수 있는 것의 장점 : 컴포넌트 별로 자를 수 있다는 것.
- SPA 안에 비어있는 Route 태그가 존재하고 여기에 view를 넣는다.
- 모던 웹의 새로운 페러다임 : 사용자 경험(UX) 향상에 있으며 부가적으로 애플리케이션 속도의 향상도 기대할 수 있음. (mobile first 전략에 부합)
- 기본적으로 웹에 필요한 리소스를 전부 다운로드 (첫 페이지 로딩에서 시간이 걸리는 문제), 그러나 다음 페이지부터는 빨라진다.(모든 리소스를 가지고 있기 때문) : 깜빡거림이 없고 부드럽게 화면전환이 가능하다.
- html에서 a태그를 누르면 href 속성이 반영되면서 주소창이 바뀌고 화면이 전환됨 (새로운 html이 다시 렌더링 되는 것), ajax는 필요한 부분만 새로 렌더링함
  - 화면전환이 되면 이미 가지고 있던 것들도 다시 가져오기에 낭비되는 자원이 많아지게 된다. 
- ajax의 경우 페이지가 많아도 각자 주소를 갖지 않고 한 페이지에 고정되므로 검색엔진에서 찾기 힘든 SEO 이슈가 생긴다. 이를 해결하기 위해서는 SSR을 사용해야 한다.
- SPA는 모든 것을 해결해주지 않는다.
- SPA는 바닐라로 구현하기 어렵다. 들이는 시간과 노력에 비해 잘 만들기가 어렵다.
- SPA의 핵심은 사용자 경험 향상(화면의 깜빡거림을 줄이고 부드럽게 만들어준다.)
- 일반적인 정보를 제공하는 것은 웹페이지, 다양한 데이터를 이용하여 작업을 할 수 있으면 애플리케이션이라고 부르는 경우가 많다.
- 웹 애플리케이션은 seo 이슈에서 비교적 자유롭다. 하지만 웹 페이지는 seo 이슈가 치명적이다.
- 화면이동을 보통 routing이라고 부른다.
### 전통적 링크 방식
- a 태그를 이용한 연결
- /는 루트 (현재 html이 온 곳) 아무것도 써 있지 않다면 index.html을 반환
- a 태그의 역할은 주소창에 요소를 붙여서 리턴을 받는 것과 같음.
- 시맨틱은 결국 seo와 관련이 있다.
- 페이지가 고유한 url을 가지고 있어야 seo에서 찾을 수 있다.
  - 구현이 편하다
  - 화면 깜빡거림과 불필요한 요소까지 다시 페인팅한다.
### ajax 방식
- id를 기본적으로 갖고, a 태그 안에 href attribute를 갖지 않는다.
- 코딩이 더 들어가고 조금 더 복잡해진다.
- 깜빡임, 불필요한 리소스의 재요청과 재페인팅을 하지 않는 장점
- 주소창이 변하지 않으므로 히스토리 기능을 사용할 수 없고 seo 이슈가 생긴다.
- reload를 작동시키면 다시 첫페이지로 돌아가버린다.

### hash 방법
- hash 앞에 한 글자라도 바뀌면 요청을 새로 발생시키지만, hash가 있는 상태에서는 새로운 요청을 하지 않는다. 이는 페이지 내에서 이동하는 것이기 때문이다.
- 주소창은 바뀌지만 요청은 새로하지 않는다.
- 정식으로 채택된 방식이라기보다는 과도기에 나옴 꼼수 방식
- 식별자 명명 규칙 (알파벳, _, $로 시작, 두번째부터 숫자 허용)
- 식별자는 스코프 체인, 프로퍼티는 프로토타입 체인에서 찾음
- 프로퍼티의 이름은 기본적으로 문자열이면 다 된다. 프로퍼티 이름은 따옴표가 붙지 않아도 붙은 것처럼 취급
- 그러므로 routes[hash]에서 대괄호 안에 오는 것은 식별자
- 스위치문을 사용하기 힘들 때 객체 리터럴로 만들어서 호출하는 방식으로 사용한다.
- seo와 히스토리, refresh에 문제가 없다.
- #이 들어가야 한다는 점에서 단점으로 꼽힘.
- #뒤에 !(느낌표)가 들어가는 것으로 hash bang 방식이라고 부른다.
- 요즘에는 잘 사용하지 않는 방식이 되었다.
- 페이지를 이동할 때마다 router 함수가 호출되는데 hash가 바뀔 때마다 페이지가 이동해야하며 hash가 바뀔 때마다 이동해야 한다.
- 'hashchange' 이벤트를 통해서 hash의 변화를 감지할 수 있다.
- 'DOMContentLoaded'는 DOM 컨텐츠가 로드되는 이벤트가 발생했을 때 사용가능하다.(load이벤트보다 먼저 발생)
  - load이벤트는 모든 리소스가 있는 상태에서 해야하는 이벤트가 있을 때 사용

### pjax(Pushstate method) 방법 (jQuery에서 일찍이 지원하던 기능)
- 구형 브라우저에서는 작동하지 않음 (대략 익스플로러 10이상부터 지원하는 방법)
- rest api 같은 형태가 되는데 서버가 반응을 해줘야하므로 백엔드에서의 지원이 필요하다.
- 보여줘야 되는 페이지만큼 서버가 가지고 있어야하므로 이것도 완벽한 방법은 아니다.

```
결론적으로 위의 4가지를 직접 만드는 것보다 프레임워크를 사용하는 것이 시간적, 비용적 관점에서 효용성이 높다.
개념에 대한 이해가 동반되어야 하므로 위의 개념들을 머릿속에 넣어놓는 것이 중요하다.
```

### 추가 설명
- DOM 어떤 언어에서든 접근이 가능해야 한다.
- addEventListenr를 사용하면 생략 가능한 3번째 인수로 캡쳐링을 잡을지 버블링을 잡을지 정할 수 있다. 생략될 경우 버블링을 잡는 것이 표준이다.

### 추가 설명 (콜백)
- 브라우저가 인수로 전달한 함수를 호출한다.