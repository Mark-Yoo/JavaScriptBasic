# Preview
## CS
- Web APIs : W3C가 표준을 제정하고 관리
- ES : ECMA 재단에서 관리하는 자바스크립트의 표준
## SERVER
- ES
- Node.js APIs
- Node.js는 run-time environment, 즉 개발을 위한 환경을 의미함(언어가 아님)

## Browser
- 브라우저가 하는 일을 제대로 아는 것도 중요하다
- 아파치(웹 서버) : 설치하는 일
- Node.js : 자바스크립트 환경을 제공하고 웹 서버를 손쉽게 만들 수 있게 해줌.
- Node.js express : 보편적으로 많이 사용되는 Node.js의  프레임 워크
- Angular : IE8 이상 지원
- 팀 버너스 리 : 통신규약(HTTP) - 클라이언트와 서버 간의 약속을 정함 (1.1 1.2 2.0 버전이 존재 : 1.0 대 버전은 주소창에 써서 보내면 요청이 감. DNS에서 실질적인 주소로 연결해줌, 일반적으로 index.html를 보내주는 것으로 서버가 알고 있다.)
version 표기 법 10.12.6 마지막부터, 버그픽스(패치), 마이너 버전, 메이저 버전(break change-전버전과 이전버전의 호환이 안 될 수 있다. 이 때는 체인지 로그를 잘 봐야함.)
    - 요청 방법과 응답 방법에 대한 약속
- 파싱(parsing) : 텍스트로 되어있는 소스코드를 이해하기 위해서 해석하는 과정(html은 순수한 text지만 이것을 컴퓨터는 읽을 수 없으므로 컴퓨터로 읽을 수 있는 언어로 해석하는 과정)
- load html : html을 다운로드 받는다. (2진수로 이루어진 집합체를 광케이블을 통해서 작은 패킷으로 나누어 스트리밍 받는 과정)
- DOM : 브라우저가 이해할 수 있는 구조로 만들었다는 것은 메모리에 올려놓았다는 것이다.
- DOM Tree : 제일 상위는 무조건 하나, 그 아래에 node(가지)들이 있다.
- 자바스크립트에서 중첩관계는 부자관계라고하지는 않지만 밀접한 관계라고 한다. (중첩 관계의 이해 매우 중요)
- get 명령어를 통해서 style.css 다운로드
- CSS : 셀렉터 하나씩으로 이루어진 룰셋들의 나열
- html 파싱 중 css 링크를 만나서 css 파싱을 하고 그 이후 중단되었던 html 파싱을 재개한다.
- 처음에 DOM과 CSSOM(CSS 파싱으로 나온 것)은 따로 분리되어 있다.
- DOM tree와 CSSOM tree을 Merge해서 Render Tree를 만든다. 
- 자바스크립트 중 src attribute가 있으면 외부 스크립트를 불러오는 일. src attribute가 없으면 자바스크립트가 내장되어있는 것.
    - 전통적으로 html, css, javascript를 다른 것으로 봐서 따로 쓰는 것을 기본으로 생각했다. 하지만 근래에는 이 셋이 하나로 움직이므로 잘게 쪼개서 한 번에 섞어서 만드는 CBD(component based development)방식의 움직임이 크다.
    - 하지만 양이 많은 코드를 보수하는 과정에서 생기는 어려움을 해결하기 위해서 따로 쓰는 경우가 많음.
- 2.0 대 버전에서는 단위별로 쪼개서 보냄
- 컴퓨터에게 가장 부하가 많이 걸리는 일은 파일을 읽고 쓰는 일.
    - 그 다음이 렌더링과 디스플레이 사이의 과정
- 자바스크립트를 파싱하고 나면 syntax tree를 만든다.
    - 파싱이 끝난 자바스크립트는 실행을 해야하는데 DOM tree 와 관련이 있을수도 없을수도 있다. Syntax tree는 dom tree와 CSSOM tree가 만들어진 후에 만들어지므로 syntax tree가 각 tree에 영향을 주는 것이 가능하다.
- syntax(문법) AST(Abstract Syntax Tree) : 
- 토큰(token) : 의미를 가진 최소 단위
- 자바스크립트는 식별자를 찾으러 lexical 안 환경까지 찾아 들어간다. 그리고 없으면 syntax error를 뽑아낸다.



- 변수 선언 방식
    - var a;
    - var a, b;
    - var a = 10; 문이 두개라고 인식
- 키워드 = 예약어
- 할당자 다음에는 값 (혹은 표현식이라고도 부름)이 와야함


- 컴파일러는 컴파일 타임 때문에 실행 파일을 만들기까지가 시간이 걸리지만 실행 파일이 만들어지면 인터프리터보다 훨씬 빠르다.
    - 컴파일러는 컴파일 과정 중에 에러를 대부분 잡으므로 안정성이 비교적 높다.
- 인터프리터 언어는 구석구석 에러를 모두 잡아내는 것이 사실상 불가능하므로 배포 후에도 에러가 생기는 경우가 많다.


- 자바스크립트에서 .은 유의미한 토큰임. console.log(x+1) (객체 property가 가지고 있는 log를 가져와라. x+1이라는 값이 log로 들어간다..)
- html head에 들어가는 데이터 : 화면에 보이지 않는 것들
    - 메타데이터 : 컴퓨터에 주기위한 데이터
    - css
    - link 등등
- body 태그에 있는 것이 head로 가면 안됨. : 뷰포트에 보여지는 것들.

# 변수란 무엇인가? 왜 필요한가?
- 변수는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체
- 컴퓨터가 기억하기 위해서 필요하다
- 컴퓨터에는 두 개의 뇌가 있다. 기억하기 위한 뇌: 메모리, 연산하기 위한 뇌: CPU
- 메모리는 셀로 이루어져 있고 셀은 1byte, 즉 8bit로 이루어져 있다.
- ASCII : 인간이 표현할수 있는 글자들을 가지고 있는 character set
- 값을 저장하고 연산을 한 다음 탄생한 새로운 값을 임의의 메모리 셀에 다시 저장한다.
- 변수는 사람이 이해할 수 있는 이름을 짓고 임의의 메모리 주소에 붙여준다.
- 주석을 많이 달지 않는게 베스트 (코드만 보고도 이해할 수 있는게 베스트. 식별자의 이름을 객관적으로 이해할 수 있게 보여줄 것. 처음부터 이름 잘 지을것.)
- 변수의 이름에 따라 들어갈 값의 타입을 유추할 수 있는 경우들이 많다. (이름의 중요성)
- 코드를 작성한 사람이 봐도 어려운 코드가 만들어졌다면 주석이 필요하다. (이럴 경우에는 나중에 코드를 다시 만들어보는 경험이 필요하다. 코드를 그렇게 짠 이유를 본인이 알아야 한다.)
- 변수는 곧 식별자 : 식별자는 값을 찾아갈 수 있는 단서

    var result = 10 + 20;
    위의 식은 아래의 의미를 모두 갖는다.
    var result;
    result = 10 + 20;
    
- 값을 만드는 것은 평가(evaluation), 실행은 하지만 새로운 값을 만드는 일은 아닌 경우는 실행(execution)
- 모든 변수명은 식별자이지만, 모든 식별자가 변수명인건 아니다. 식별자가 포괄적인 개념
- 식별자는 선언(declaration)과 관련이 있음.
## 변수 선언이란?
    var a;
    a = 1;
    console.log(a)

- 선언문은 식별자를 가지고 있다.
- 자바스크립트는 변수를 선언하면 undefined로 초기화를 해준다.
- 정의(define)란 식별자의 정체를 알리는것 : 현재 변수에 할당된 값. undefined 역시 값. 개발자가 아무것도 할당하지 않았을 때에 갖게 되는 원시(primitive) 값

- var가 존재하는데도 불구하고 let, const가 만들어진 이유
    - var는 중복선언이 가능한 문제가 있다. 다시 선언할 경우 이전에 할당된 값이 다시 나오는 경우도 생긴다.
    - 중복선언시에 자바스크립트는 그 변수명이 있는지 찾아간다. 자바스크립트는 실수라고 생각하고 본인이 가지고 있는 값을 참조한다. (엄격한 기준을 가지고 있지 않은 문제)