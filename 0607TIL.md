# 0507TIL
- 자바스크립트에서 .prototype은 식별자로 취급하지 않는다. Object.prototype은 객체이므로 .x를 사용하는 것이 가능하다.
- Object.prototype은 Object가 만들어질 때 존재하므로 결국 태초부터 존재하게 된다.
- 기본적으로 자바스크립트 엔진은 프로퍼티에 접근하면 모든 객체가 가지고 있는 내부 메서드 [[Get]]을 호출한다. [[get]]이 있으면 세트로 오는 [[set]]도 존재한다. [[get]]은 프로토타입 체인에서 찾아준다. [[set]]은 찾는 역할을 수행하다가 없으면 추가하고 할당한다.(만약 찾는 것이 존재할 경우 새로운 값으로 갱신한다.)
- 프로토타입과 스코프는 둘이 협력해서 값을 평가하는 역할을 한다.
- window 위로 몇 단계를 올라가면 Object.prototype이 연결된다.
- 객체리터럴은 할당 직전에 객체가 만들어진다.
- 실행 컨텍스트는 4가지 실행가능한 코드들만 만들기 때문에 for문이나 if문은 실행 컨텍스트를 만들지 못하고 렉시컬 환경만 만든다. 그렇기 때문에 함수 내부에서 블록 스코프를 가지는 렉시컬 환경이 만들어지면 함수의 실행 컨텍스트는 블록 렉시컬 환경과 연결이 되고 블록 실행이 끝나면 다시 함수 렉시컬 환경으로 돌아간다. (13.2.13)
- 클로저의 주목적은 '안전한' 상태 유지 (전역 변수를 이용하면 상태 유지를 할 수는 있지만 안전하게는 상태 유지를 할 수 없다.) (property를 이용하는 것도 상태 유지가 가능)
```
전역 변수의 문제
const o = {
  name: 'LEE'
  sayHi() {
    console.log(this.name)
  }
}
- 객체의 모든 프로퍼티가 public이라는 문제가 생긴다. 클로저를 이용하면 안전하게 사용할 수 있다.
```
# 클로저
- 함수형 프로그래밍 언어에서 오래전부터 존재했던 개념
- 하스켈(Haskell)을 공부하면 함수형 프로그래밍 언어를 이해하는데에 도움이 된다.
- 실행중인 실행 컨텍스트의 렉시컬 환경의 환경 레코드에서 찾는다. 환경 레드에 없으면 외부 렉시컬 환경 레코드를 타고 올라간다.
- 렉시컬에서 중요한 것은 어디에서 호출되었는지보다 어디에서 정의되었는느냐이다.
- 대부분의 프로그래밍 언어는 정적 스코프를 지원한다.
- 함수가 태어나서 함수 객체가 될 때 상위스코프는 이미 결정된다.(자신이 정의된 위치에 따라서) 렉시컬 환경에 대한 참조를 [[environment]]슬롯에 담아놓고 있다.
- 함수가 함수를 리턴할 수 있는 이유는 일급 객체이기 때문이다.(고차함수)
```
모든 함수는 이론적으로 클로저이지만 최신 브라우저의 동작 형태에 따르면 아래의 두가지를 만족해야 클로저로 남는다.
  1. 상위 스코프의 어떠한 식별자를 하나라도 보고 있어야 클로저라고 할 수 있다.
  2. 중첩 함수가 외부 함수보다 더 오래 살아남아야 한다.
```
## 클로저의 활용
- 상태가 의도치 않게 변경되지 않도록 안전하게 은닉(Information hiding)한다.
- 최신상태를 유지한다.(가장 본질적인 이유)

```
<!DOCTYPE html>
<html>
<body>
  <button class="increase">+</button>
  <span class="counter">0</span>

  <script>
    const $counter = document.querySelector('.counter');

    const increase = (function () {
      // 카운트 상태를 유지하기 위한 자유 변수
      let num = 0;

      return function () {
        $counter.textContent = ++num;
      };
    }());

    document.querySelector('.increase').onclick = increase;
  </script>
</body>
</html>

- 즉시 실행함수가 내부에서 리턴하는 함수의 상위 스코프가 되므로 increase는 함수 객체를 담고 있게 된다.
호출이 되어야 콜스택에 들어가서 실행이 되는데, 브라우저가 onclick 이벤트가 발생하면 increase가 실행된다.
```
- mutable한 객체를 immutable하게 사용하기 위해서 얼린다. 그러기 위해서 deep copy를 한다.
- 함수는 외부 상태를 절대 변경하지 않으며 본인이 가진 내부만을 변경하는 것을 지향한다.

- 즉시실행함수 혹은 모듈로 상태를 보장하는 것이 가능하다.
  - 모듈을 사용하면 import, export를 사용하여 내부의 변수를 공개할 것과 공개하지 않을 것을 지원한다.
- 캡슐화와 정보 은닉은 같은 말이 아니다. 캡슐화는 정보 은닉으로만 되는 것은 아니다.
- 클로저는 정보 은닉을 통해서 상태를 안전하게 저장한다.

### 클로저 문제
- 전역에서 실행되는 for문 내에서 let으로 변수를 선언했을 경우, 상위 스코프를 for문 뒤의 조건으로 잡는다. 이 때 순회가 돌 때마다 렉시컬 환경을 각각 만들고 변수를 할당한다. 하지만 함수가 보고있지 않으면 참조하고 있는 곳이 없어 garbage collector의 대상이 되어 사라진다. 함수가 있어야 각 순회마다 만들어지는 렉시컬 환경을 바라보게 된다. 이렇게 함수 객체가 가지는 내부 슬롯 [[environment]]의 스코프는 자신의 상위 스코프를 가리키게 되므로 for문에서 생성한 각 렉시컬 환경을 가리키게 된다.
- 모든 iterable은 for of를 사용할 수 있다. (of 뒤에는 항상 iterable이 와야한다.)
- for in은 const에서도 사용할 수 있다. 이는 스코프 내에서 계속 새로운 컨텍스트가 만들어지므로 가능한것이다.